// Code generated by cmd/cgo; DO NOT EDIT.

//line /root/go/src/github.com/cypherium/cypher/crypto/bls/bls.go:1:1
package bls

/*
#cgo CFLAGS:-DMCLBN_FP_UNIT_SIZE=4 -Iinclude
#cgo LDFLAGS: -Llib -lbls256 -lmcl

#cgo bn256 CFLAGS:-DMCLBN_FP_UNIT_SIZE=4 -Iinclude
#cgo bn256 LDFLAGS: -Llib -lbls256 -lmcl
#cgo bn384 CFLAGS:-DMCLBN_FP_UNIT_SIZE=6 -Iinclude
#cgo bn384 LDFLAGS: -Llib -lbls384 -lmcl
#cgo bn384_256 CFLAGS:-DMCLBN_FP_UNIT_SIZE=6 -DMCLBN_FR_UNIT_SIZE=4 -Iinclude
#cgo bn384_256 LDFLAGS: -Llib -lbls384_256 -lmcl
#cgo LDFLAGS:-L/usr/local/opt/openssl/lib -lcrypto -lgmp -lgmpxx -lstdc++

#cgo bn256_swapg CFLAGS:-DMCLBN_FP_UNIT_SIZE=4 -DBLS_SWAP_G
#cgo bn256_swapg LDFLAGS:-lbls256
#cgo bn384_swapg CFLAGS:-DMCLBN_FP_UNIT_SIZE=6 -DBLS_SWAP_G
#cgo bn384_swapg LDFLAGS:-lbls384
#cgo bn384_256_swapg CFLAGS:-DMCLBN_FP_UNIT_SIZE=6 -DMCLBN_FR_UNIT_SIZE=4 -DBLS_SWAP_G
#cgo bn384_256_swapg LDFLAGS:-lbls384_256
#cgo LDFLAGS:-lcrypto -lgmp -lgmpxx -lstdc++
typedef unsigned int (*ReadRandFunc)(void *, void *, unsigned int);
int wrapReadRandCgo(void *self, void *buf, unsigned int n);
#include <bls/bls.h>
*/
import _ "unsafe"
import "fmt"
import "unsafe"
import "io"
import "encoding/hex"

func hex2byte(s string) ([]byte, error) {
	if (len(s) & 1) == 1 {
		return nil, fmt.Errorf("odd length")
	}
	return hex.DecodeString(s)
}

// Init --
// call this function before calling all the other operations
// this function is not thread safe
func Init(curve int) error {
	err := ( /*line :43:9*/_Cfunc_blsInit /*line :43:17*/)( /*line :43:19*/_Ctype_int /*line :43:24*/(curve), ( /*line :43:33*/_Ciconst_MCLBN_COMPILED_TIME_VAR /*line :43:57*/))
	if err != 0 {
		return fmt.Errorf("ERR Init curve=%d", curve)
	}
	return nil
}

// ID --
type ID struct {
	v  /*line :52:4*/_Ctype_blsId /*line :52:11*/
}

// Serialize --
func (id *ID) Serialize() []byte {
	buf := make([]byte, 2048)
	// #nosec
	n := func() _Ctype_size_t{ _cgoIndex0 := &/*line :59:40*/buf; _cgo0 := /*line :59:24*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_size_t = _Ctype_mclSize /*line :59:58*/(len(buf)); var _cgo2 *_Ctype_struct___6 = /*line :59:70*/&id.v; _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :59:76*/_Cfunc_blsIdSerialize(_cgo0, _cgo1, _cgo2); }()
	if n == 0 {
		panic("err blsIdSerialize")
	}
	return buf[:n]
}

// Deserialize --
func (id *ID) Deserialize(buf []byte) error {
	// #nosec
	err := func() _Ctype_size_t{ var _cgo0 *_Ctype_struct___6 = /*line :69:28*/&id.v; _cgoIndex1 := &/*line :69:51*/buf; _cgo1 := /*line :69:35*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = _Ctype_mclSize /*line :69:69*/(len(buf)); _cgoCheckPointer(_cgo1, *_cgoIndex1); return /*line :69:80*/_Cfunc_blsIdDeserialize(_cgo0, _cgo1, _cgo2); }()
	if err == 0 {
		return fmt.Errorf("err blsIdDeserialize %x", buf)
	}
	return nil
}

// GetLittleEndian -- alias of Serialize
func (id *ID) GetLittleEndian() []byte {
	return id.Serialize()
}

// SetLittleEndian --
func (id *ID) SetLittleEndian(buf []byte) error {
	// #nosec
	err := func() _Ctype_int{ var _cgo0 *_Ctype_struct___6 = /*line :84:32*/&id.v; _cgoIndex1 := &/*line :84:55*/buf; _cgo1 := /*line :84:39*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = _Ctype_mclSize /*line :84:73*/(len(buf)); _cgoCheckPointer(_cgo1, *_cgoIndex1); return /*line :84:84*/_Cfunc_blsIdSetLittleEndian(_cgo0, _cgo1, _cgo2); }()
	if err != 0 {
		return fmt.Errorf("err blsIdSetLittleEndian %x", err)
	}
	return nil
}

// SerializeToHexStr --
func (id *ID) SerializeToHexStr() string {
	return hex.EncodeToString(id.Serialize())
}

// DeserializeHexStr --
func (id *ID) DeserializeHexStr(s string) error {
	a, err := hex2byte(s)
	if err != nil {
		return err
	}
	return id.Deserialize(a)
}

// GetHexString --
func (id *ID) GetHexString() string {
	buf := make([]byte, 2048)
	// #nosec
	n := ( /*line :109:7*/_Cfunc_blsIdGetHexStr /*line :109:22*/)((* /*line :109:26*/_Ctype_char /*line :109:32*/)(unsafe.Pointer(&buf[0])),  /*line :109:60*/_Ctype_mclSize /*line :109:69*/(len(buf)), &id.v)
	if n == 0 {
		panic("err blsIdGetHexStr")
	}
	return string(buf[:n])
}

// GetDecString --
func (id *ID) GetDecString() string {
	buf := make([]byte, 2048)
	// #nosec
	n := ( /*line :120:7*/_Cfunc_blsIdGetDecStr /*line :120:22*/)((* /*line :120:26*/_Ctype_char /*line :120:32*/)(unsafe.Pointer(&buf[0])),  /*line :120:60*/_Ctype_mclSize /*line :120:69*/(len(buf)), &id.v)
	if n == 0 {
		panic("err blsIdGetDecStr")
	}
	return string(buf[:n])
}

// SetHexString --
func (id *ID) SetHexString(s string) error {
	buf := []byte(s)
	// #nosec
	err := ( /*line :131:9*/_Cfunc_blsIdSetHexStr /*line :131:24*/)(&id.v, (* /*line :131:35*/_Ctype_char /*line :131:41*/)(unsafe.Pointer(&buf[0])),  /*line :131:69*/_Ctype_mclSize /*line :131:78*/(len(buf)))
	if err != 0 {
		return fmt.Errorf("err blsIdSetHexStr %s", s)
	}
	return nil
}

// SetDecString --
func (id *ID) SetDecString(s string) error {
	buf := []byte(s)
	// #nosec
	err := ( /*line :142:9*/_Cfunc_blsIdSetDecStr /*line :142:24*/)(&id.v, (* /*line :142:35*/_Ctype_char /*line :142:41*/)(unsafe.Pointer(&buf[0])),  /*line :142:69*/_Ctype_mclSize /*line :142:78*/(len(buf)))
	if err != 0 {
		return fmt.Errorf("err blsIdSetDecStr %s", s)
	}
	return nil
}

// IsEqual --
func (id *ID) IsEqual(rhs *ID) bool {
	if id == nil || rhs == nil {
		return false
	}
	return ( /*line :154:9*/_Cfunc_blsIdIsEqual /*line :154:22*/)(&id.v, &rhs.v) == 1
}

// SecretKey --
type SecretKey struct {
	v  /*line :159:4*/_Ctype_blsSecretKey /*line :159:18*/
}

// Serialize --
func (sec *SecretKey) Serialize() []byte {
	buf := make([]byte, 2048)
	// #nosec
	n := func() _Ctype_size_t{ _cgoIndex0 := &/*line :166:47*/buf; _cgo0 := /*line :166:31*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_size_t = _Ctype_mclSize /*line :166:65*/(len(buf)); var _cgo2 *_Ctype_struct___2 = /*line :166:77*/&sec.v; _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :166:84*/_Cfunc_blsSecretKeySerialize(_cgo0, _cgo1, _cgo2); }()
	if n == 0 {
		panic("err blsSecretKeySerialize")
	}
	return buf[:n]
}

// Deserialize --
func (sec *SecretKey) Deserialize(buf []byte) error {
	// #nosec
	err := func() _Ctype_size_t{ var _cgo0 *_Ctype_struct___2 = /*line :176:35*/&sec.v; _cgoIndex1 := &/*line :176:59*/buf; _cgo1 := /*line :176:43*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = _Ctype_mclSize /*line :176:77*/(len(buf)); _cgoCheckPointer(_cgo1, *_cgoIndex1); return /*line :176:88*/_Cfunc_blsSecretKeyDeserialize(_cgo0, _cgo1, _cgo2); }()
	if err == 0 {
		return fmt.Errorf("err blsSecretKeyDeserialize %x", buf)
	}
	return nil
}

// GetLittleEndian -- alias of Serialize
func (sec *SecretKey) GetLittleEndian() []byte {
	return sec.Serialize()
}

// SetLittleEndian --
func (sec *SecretKey) SetLittleEndian(buf []byte) error {
	// #nosec
	err := func() _Ctype_int{ var _cgo0 *_Ctype_struct___2 = /*line :191:39*/&sec.v; _cgoIndex1 := &/*line :191:63*/buf; _cgo1 := /*line :191:47*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = _Ctype_mclSize /*line :191:81*/(len(buf)); _cgoCheckPointer(_cgo1, *_cgoIndex1); return /*line :191:92*/_Cfunc_blsSecretKeySetLittleEndian(_cgo0, _cgo1, _cgo2); }()
	if err != 0 {
		return fmt.Errorf("err blsSecretKeySetLittleEndian %x", err)
	}
	return nil
}

// SerializeToHexStr --
func (sec *SecretKey) SerializeToHexStr() string {
	return hex.EncodeToString(sec.Serialize())
}

// DeserializeHexStr --
func (sec *SecretKey) DeserializeHexStr(s string) error {
	a, err := hex2byte(s)
	if err != nil {
		return err
	}
	return sec.Deserialize(a)
}

// GetHexString --
func (sec *SecretKey) GetHexString() string {
	buf := make([]byte, 2048)
	// #nosec
	n := ( /*line :216:7*/_Cfunc_blsSecretKeyGetHexStr /*line :216:29*/)((* /*line :216:33*/_Ctype_char /*line :216:39*/)(unsafe.Pointer(&buf[0])),  /*line :216:67*/_Ctype_mclSize /*line :216:76*/(len(buf)), &sec.v)
	if n == 0 {
		panic("err blsSecretKeyGetHexStr")
	}
	return string(buf[:n])
}

// GetDecString --
func (sec *SecretKey) GetDecString() string {
	buf := make([]byte, 2048)
	// #nosec
	n := ( /*line :227:7*/_Cfunc_blsSecretKeyGetDecStr /*line :227:29*/)((* /*line :227:33*/_Ctype_char /*line :227:39*/)(unsafe.Pointer(&buf[0])),  /*line :227:67*/_Ctype_mclSize /*line :227:76*/(len(buf)), &sec.v)
	if n == 0 {
		panic("err blsSecretKeyGetDecStr")
	}
	return string(buf[:n])
}

// SetHexString --
func (sec *SecretKey) SetHexString(s string) error {
	buf := []byte(s)
	// #nosec
	err := ( /*line :238:9*/_Cfunc_blsSecretKeySetHexStr /*line :238:31*/)(&sec.v, (* /*line :238:43*/_Ctype_char /*line :238:49*/)(unsafe.Pointer(&buf[0])),  /*line :238:77*/_Ctype_mclSize /*line :238:86*/(len(buf)))
	if err != 0 {
		return fmt.Errorf("err blsSecretKeySetHexStr %s", s)
	}
	return nil
}

// SetDecString --
func (sec *SecretKey) SetDecString(s string) error {
	buf := []byte(s)
	// #nosec
	err := ( /*line :249:9*/_Cfunc_blsSecretKeySetDecStr /*line :249:31*/)(&sec.v, (* /*line :249:43*/_Ctype_char /*line :249:49*/)(unsafe.Pointer(&buf[0])),  /*line :249:77*/_Ctype_mclSize /*line :249:86*/(len(buf)))
	if err != 0 {
		return fmt.Errorf("err blsSecretKeySetDecStr %s", s)
	}
	return nil
}

// IsEqual --
func (sec *SecretKey) IsEqual(rhs *SecretKey) bool {
	if sec == nil || rhs == nil {
		return false
	}
	return ( /*line :261:9*/_Cfunc_blsSecretKeyIsEqual /*line :261:29*/)(&sec.v, &rhs.v) == 1
}

// SetByCSPRNG --
func (sec *SecretKey) SetByCSPRNG() {
	err := ( /*line :266:9*/_Cfunc_blsSecretKeySetByCSPRNG /*line :266:33*/)(&sec.v)
	if err != 0 {
		panic("err blsSecretKeySetByCSPRNG")
	}
}

// Add --
func (sec *SecretKey) Add(rhs *SecretKey) {
	( /*line :274:2*/_Cfunc_blsSecretKeyAdd /*line :274:18*/)(&sec.v, &rhs.v)
}

// GetMasterSecretKey --
func (sec *SecretKey) GetMasterSecretKey(k int) (msk []SecretKey) {
	msk = make([]SecretKey, k)
	msk[0] = *sec
	for i := 1; i < k; i++ {
		msk[i].SetByCSPRNG()
	}
	return msk
}

// GetMasterPublicKey --
func GetMasterPublicKey(msk []SecretKey) (mpk []PublicKey) {
	n := len(msk)
	mpk = make([]PublicKey, n)
	for i := 0; i < n; i++ {
		mpk[i] = *msk[i].GetPublicKey()
	}
	return mpk
}

// Set --
func (sec *SecretKey) Set(msk []SecretKey, id *ID) error {
	// #nosec
	ret := ( /*line :300:9*/_Cfunc_blsSecretKeyShare /*line :300:27*/)(&sec.v, &msk[0].v, ( /*line :300:49*/_Ctype_mclSize /*line :300:58*/)(len(msk)), &id.v)
	if ret != 0 {
		return fmt.Errorf("err blsSecretKeyShare")
	}
	return nil
}

// Recover --
func (sec *SecretKey) Recover(secVec []SecretKey, idVec []ID) error {
	if len(secVec) != len(idVec) {
		return fmt.Errorf("err SecretKey.Recover bad size")
	}
	// #nosec
	ret := ( /*line :313:9*/_Cfunc_blsSecretKeyRecover /*line :313:29*/)(&sec.v, &secVec[0].v, (* /*line :313:55*/_Ctype_blsId /*line :313:62*/)(&idVec[0].v), ( /*line :313:79*/_Ctype_mclSize /*line :313:88*/)(len(idVec)))
	if ret != 0 {
		return fmt.Errorf("err blsSecretKeyRecover")
	}
	return nil
}

// GetPop --
func (sec *SecretKey) GetPop() (sig *Sign) {
	sig = new(Sign)
	( /*line :323:2*/_Cfunc_blsGetPop /*line :323:12*/)(&sig.v, &sec.v)
	return sig
}

// PublicKey --
type PublicKey struct {
	v  /*line :329:4*/_Ctype_blsPublicKey /*line :329:18*/
}

func GetPublicKey(buf []byte) *PublicKey {
	pub := &PublicKey{}
	if err := pub.Deserialize(buf); err != nil {
		//log.Debug("bls.PublicKey.Deserialize", "invalid public key", buf, "error", err)
		return nil
	}
	return pub
}

/*
var m_cacheBlsPubs = make(map[string]*PublicKey)
func GetPublicKey(buf []byte) *PublicKey {
	key := string(buf)
	pub, ok := m_cacheBlsPubs[key]
	if ok {
		return pub
	}
	pub = &PublicKey{}
	if err := pub.Deserialize(buf); err != nil {
		//log.Debug("bls.PublicKey.Deserialize", "invalid public key", key, "error", err)
		return nil
	}
	m_cacheBlsPubs[key] = pub
	return pub
}
*/
// Serialize --
func (pub *PublicKey) Serialize() []byte {
	buf := make([]byte, 2048)
	// #nosec
	n := func() _Ctype_size_t{ _cgoIndex0 := &/*line :362:47*/buf; _cgo0 := /*line :362:31*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_size_t = _Ctype_mclSize /*line :362:65*/(len(buf)); var _cgo2 *_Ctype_struct___0 = /*line :362:77*/&pub.v; _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :362:84*/_Cfunc_blsPublicKeySerialize(_cgo0, _cgo1, _cgo2); }()
	if n == 0 {
		panic("err blsPublicKeySerialize")
	}
	return buf[:n]
}

// Deserialize --
func (pub *PublicKey) Deserialize(buf []byte) error {
	// #nosec
	err := func() _Ctype_size_t{ var _cgo0 *_Ctype_struct___0 = /*line :372:35*/&pub.v; _cgoIndex1 := &/*line :372:59*/buf; _cgo1 := /*line :372:43*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = _Ctype_mclSize /*line :372:77*/(len(buf)); _cgoCheckPointer(_cgo1, *_cgoIndex1); return /*line :372:88*/_Cfunc_blsPublicKeyDeserialize(_cgo0, _cgo1, _cgo2); }()
	if err == 0 {
		return fmt.Errorf("err blsPublicKeyDeserialize %x", buf)
	}
	return nil
}

// SerializeToHexStr --
func (pub *PublicKey) SerializeToHexStr() string {
	return hex.EncodeToString(pub.Serialize())
}

// DeserializeHexStr --
func (pub *PublicKey) DeserializeHexStr(s string) error {
	a, err := hex2byte(s)
	if err != nil {
		return err
	}
	return pub.Deserialize(a)
}

// GetHexString --
func (pub *PublicKey) GetHexString() string {
	buf := make([]byte, 2048)
	// #nosec
	n := ( /*line :397:7*/_Cfunc_blsPublicKeyGetHexStr /*line :397:29*/)((* /*line :397:33*/_Ctype_char /*line :397:39*/)(unsafe.Pointer(&buf[0])),  /*line :397:67*/_Ctype_mclSize /*line :397:76*/(len(buf)), &pub.v)
	if n == 0 {
		panic("err blsPublicKeyGetHexStr")
	}
	return string(buf[:n])
}

// SetHexString --
func (pub *PublicKey) SetHexString(s string) error {
	buf := []byte(s)
	// #nosec
	err := ( /*line :408:9*/_Cfunc_blsPublicKeySetHexStr /*line :408:31*/)(&pub.v, (* /*line :408:43*/_Ctype_char /*line :408:49*/)(unsafe.Pointer(&buf[0])),  /*line :408:77*/_Ctype_mclSize /*line :408:86*/(len(buf)))
	if err != 0 {
		return fmt.Errorf("err blsPublicKeySetHexStr %s", s)
	}
	return nil
}

// IsEqual --
func (pub *PublicKey) IsEqual(rhs *PublicKey) bool {
	if pub == nil || rhs == nil {
		return false
	}
	return ( /*line :420:9*/_Cfunc_blsPublicKeyIsEqual /*line :420:29*/)(&pub.v, &rhs.v) == 1
}

// Add --
func (pub *PublicKey) Add(rhs *PublicKey) {
	( /*line :425:2*/_Cfunc_blsPublicKeyAdd /*line :425:18*/)(&pub.v, &rhs.v)
}

// Set --
func (pub *PublicKey) Set(mpk []PublicKey, id *ID) error {
	// #nosec
	ret := ( /*line :431:9*/_Cfunc_blsPublicKeyShare /*line :431:27*/)(&pub.v, &mpk[0].v, ( /*line :431:49*/_Ctype_mclSize /*line :431:58*/)(len(mpk)), &id.v)
	if ret != 0 {
		return fmt.Errorf("err blsPublicKeyShare")
	}
	return nil
}

// Recover --
func (pub *PublicKey) Recover(pubVec []PublicKey, idVec []ID) error {
	if len(pubVec) != len(idVec) {
		return fmt.Errorf("err PublicKey.Recover bad size")
	}
	// #nosec
	ret := ( /*line :444:9*/_Cfunc_blsPublicKeyRecover /*line :444:29*/)(&pub.v, &pubVec[0].v, (* /*line :444:55*/_Ctype_blsId /*line :444:62*/)(&idVec[0].v), ( /*line :444:79*/_Ctype_mclSize /*line :444:88*/)(len(idVec)))
	if ret != 0 {
		return fmt.Errorf("err blsPublicKeyRecover")
	}
	return nil
}

// Sign  --
type Sign struct {
	v  /*line :453:4*/_Ctype_blsSignature /*line :453:18*/
}

// Serialize --
func (sig *Sign) Serialize() []byte {
	buf := make([]byte, 2048)
	// #nosec
	n := func() _Ctype_size_t{ _cgoIndex0 := &/*line :460:47*/buf; _cgo0 := /*line :460:31*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_size_t = _Ctype_mclSize /*line :460:65*/(len(buf)); var _cgo2 *_Ctype_struct___4 = /*line :460:77*/&sig.v; _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :460:84*/_Cfunc_blsSignatureSerialize(_cgo0, _cgo1, _cgo2); }()
	if n == 0 {
		panic("err blsSignatureSerialize")
	}
	return buf[:n]
}

// Deserialize --
func (sig *Sign) Deserialize(buf []byte) error {
	// #nosec
	err := func() _Ctype_size_t{ var _cgo0 *_Ctype_struct___4 = /*line :470:35*/&sig.v; _cgoIndex1 := &/*line :470:59*/buf; _cgo1 := /*line :470:43*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = _Ctype_mclSize /*line :470:77*/(len(buf)); _cgoCheckPointer(_cgo1, *_cgoIndex1); return /*line :470:88*/_Cfunc_blsSignatureDeserialize(_cgo0, _cgo1, _cgo2); }()
	if err == 0 {
		return fmt.Errorf("err blsSignatureDeserialize %x", buf)
	}
	return nil
}

// SerializeToHexStr --
func (sig *Sign) SerializeToHexStr() string {
	return hex.EncodeToString(sig.Serialize())
}

// DeserializeHexStr --
func (sig *Sign) DeserializeHexStr(s string) error {
	a, err := hex2byte(s)
	if err != nil {
		return err
	}
	return sig.Deserialize(a)
}

// GetHexString --
func (sig *Sign) GetHexString() string {
	buf := make([]byte, 2048)
	// #nosec
	n := ( /*line :495:7*/_Cfunc_blsSignatureGetHexStr /*line :495:29*/)((* /*line :495:33*/_Ctype_char /*line :495:39*/)(unsafe.Pointer(&buf[0])),  /*line :495:67*/_Ctype_mclSize /*line :495:76*/(len(buf)), &sig.v)
	if n == 0 {
		panic("err blsSignatureGetHexStr")
	}
	return string(buf[:n])
}

// SetHexString --
func (sig *Sign) SetHexString(s string) error {
	buf := []byte(s)
	// #nosec
	err := ( /*line :506:9*/_Cfunc_blsSignatureSetHexStr /*line :506:31*/)(&sig.v, (* /*line :506:43*/_Ctype_char /*line :506:49*/)(unsafe.Pointer(&buf[0])),  /*line :506:77*/_Ctype_mclSize /*line :506:86*/(len(buf)))
	if err != 0 {
		return fmt.Errorf("err blsSignatureSetHexStr %s", s)
	}
	return nil
}

// IsEqual --
func (sig *Sign) IsEqual(rhs *Sign) bool {
	if sig == nil || rhs == nil {
		return false
	}
	return ( /*line :518:9*/_Cfunc_blsSignatureIsEqual /*line :518:29*/)(&sig.v, &rhs.v) == 1
}

// GetPublicKey --
func (sec *SecretKey) GetPublicKey() (pub *PublicKey) {
	pub = new(PublicKey)
	( /*line :524:2*/_Cfunc_blsGetPublicKey /*line :524:18*/)(&pub.v, &sec.v)
	return pub
}

// Sign -- Constant Time version
func (sec *SecretKey) Sign(m string) (sig *Sign) {
	sig = new(Sign)
	buf := []byte(m)
	// #nosec
	func() { var _cgo0 *_Ctype_struct___4 = /*line :533:12*/&sig.v; var _cgo1 *_Ctype_struct___2 = /*line :533:20*/&sec.v; _cgoIndex2 := &/*line :533:44*/buf; _cgo2 := /*line :533:28*/unsafe.Pointer(&(*_cgoIndex2)[0]); var _cgo3 _Ctype_size_t = _Ctype_mclSize /*line :533:62*/(len(buf)); _cgoCheckPointer(_cgo2, *_cgoIndex2); /*line :533:73*/_Cfunc_blsSign(_cgo0, _cgo1, _cgo2, _cgo3); }()
	return sig
}

// Add --
func (sig *Sign) Add(rhs *Sign) {
	( /*line :539:2*/_Cfunc_blsSignatureAdd /*line :539:18*/)(&sig.v, &rhs.v)
}

// Recover --
func (sig *Sign) Recover(sigVec []Sign, idVec []ID) error {
	if len(sigVec) != len(idVec) {
		return fmt.Errorf("err Sign.Recover bad size")
	}
	// #nosec
	ret := ( /*line :548:9*/_Cfunc_blsSignatureRecover /*line :548:29*/)(&sig.v, &sigVec[0].v, (* /*line :548:55*/_Ctype_blsId /*line :548:62*/)(&idVec[0].v), ( /*line :548:79*/_Ctype_mclSize /*line :548:88*/)(len(idVec)))
	if ret != 0 {
		return fmt.Errorf("err blsSignatureRecover")
	}
	return nil
}

// Verify --
func (sig *Sign) Verify(pub *PublicKey, m string) bool {
	if sig == nil || pub == nil {
		return false
	}
	buf := []byte(m)
	// #nosec
	return func() _Ctype_int{ var _cgo0 *_Ctype_struct___4 = /*line :562:21*/&sig.v; var _cgo1 *_Ctype_struct___0 = /*line :562:29*/&pub.v; _cgoIndex2 := &/*line :562:53*/buf; _cgo2 := /*line :562:37*/unsafe.Pointer(&(*_cgoIndex2)[0]); var _cgo3 _Ctype_size_t = _Ctype_mclSize /*line :562:71*/(len(buf)); _cgoCheckPointer(_cgo2, *_cgoIndex2); return /*line :562:82*/_Cfunc_blsVerify(_cgo0, _cgo1, _cgo2, _cgo3); }() == 1
}

// VerifyPop --
func (sig *Sign) VerifyPop(pub *PublicKey) bool {
	if sig == nil || pub == nil {
		return false
	}
	return ( /*line :570:9*/_Cfunc_blsVerifyPop /*line :570:22*/)(&sig.v, &pub.v) == 1
}

// DHKeyExchange --
func DHKeyExchange(sec *SecretKey, pub *PublicKey) (out PublicKey) {
	( /*line :575:2*/_Cfunc_blsDHKeyExchange /*line :575:19*/)(&out.v, &sec.v, &pub.v)
	return out
}

// HashAndMapToSignature --
func HashAndMapToSignature(buf []byte) *Sign {
	sig := new(Sign)
	// #nosec
	err := func() _Ctype_int{ var _cgo0 *_Ctype_struct___4 = /*line :583:30*/&sig.v; _cgoIndex1 := &/*line :583:54*/buf; _cgo1 := /*line :583:38*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = _Ctype_mclSize /*line :583:72*/(len(buf)); _cgoCheckPointer(_cgo1, *_cgoIndex1); return /*line :583:83*/_Cfunc_blsHashToSignature(_cgo0, _cgo1, _cgo2); }()
	if err != 0 {
		return nil
	}
	return sig
}

// VerifyPairing --
func VerifyPairing(X *Sign, Y *Sign, pub *PublicKey) bool {
	if X == nil || Y == nil || pub == nil {
		return false
	}
	return ( /*line :595:9*/_Cfunc_blsVerifyPairing /*line :595:26*/)(&X.v, &Y.v, &pub.v) == 1
}

// SignHash --
func (sec *SecretKey) SignHash(hash []byte) (sig *Sign) {
	sig = new(Sign)
	// #nosec
	err := func() _Ctype_int{ var _cgo0 *_Ctype_struct___4 = /*line :602:23*/&sig.v; var _cgo1 *_Ctype_struct___2 = /*line :602:31*/&sec.v; _cgoIndex2 := &/*line :602:55*/hash; _cgo2 := /*line :602:39*/unsafe.Pointer(&(*_cgoIndex2)[0]); var _cgo3 _Ctype_size_t = _Ctype_mclSize /*line :602:74*/(len(hash)); _cgoCheckPointer(_cgo2, *_cgoIndex2); return /*line :602:86*/_Cfunc_blsSignHash(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if err == 0 {
		return sig
	}
	return nil
}

// VerifyHash --
func (sig *Sign) VerifyHash(pub *PublicKey, hash []byte) bool {
	if pub == nil {
		return false
	}
	// #nosec
	return func() _Ctype_int{ var _cgo0 *_Ctype_struct___4 = /*line :615:25*/&sig.v; var _cgo1 *_Ctype_struct___0 = /*line :615:33*/&pub.v; _cgoIndex2 := &/*line :615:57*/hash; _cgo2 := /*line :615:41*/unsafe.Pointer(&(*_cgoIndex2)[0]); var _cgo3 _Ctype_size_t = _Ctype_mclSize /*line :615:76*/(len(hash)); _cgoCheckPointer(_cgo2, *_cgoIndex2); return /*line :615:88*/_Cfunc_blsVerifyHash(_cgo0, _cgo1, _cgo2, _cgo3); }() == 1
}

func min(x, y int) int {
	if x < y {
		return x
	}
	return y
}

// VerifyAggregateHashes --
func (sig *Sign) VerifyAggregateHashes(pubVec []PublicKey, hash [][]byte) bool {
	if pubVec == nil {
		return false
	}
	n := len(hash)
	if n == 0 {
		return false
	}
	hashByte := GetOpUnitSize() * 8
	h := make([]byte, n*hashByte)
	for i := 0; i < n; i++ {
		hn := len(hash[i])
		copy(h[i*hashByte:(i+1)*hashByte], hash[i][0:min(hn, hashByte)])
	}
	return func() _Ctype_int{ var _cgo0 *_Ctype_struct___4 = /*line :640:37*/&sig.v; var _cgo1 *_Ctype_struct___0 = /*line :640:45*/&pubVec[0].v; _cgoIndex2 := &/*line :640:75*/h; _cgo2 := /*line :640:59*/unsafe.Pointer(&(*_cgoIndex2)[0]); var _cgo3 _Ctype_size_t = _Ctype_mclSize /*line :640:91*/(hashByte); var _cgo4 _Ctype_size_t = _Ctype_mclSize /*line :640:112*/(n); _cgoCheckPointer(_cgo2, *_cgoIndex2); return /*line :640:116*/_Cfunc_blsVerifyAggregatedHashes(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() == 1
}

///

var sRandReader io.Reader

func createSlice(buf * /*line :647:23*/_Ctype_char /*line :647:29*/, n  /*line :647:33*/_Ctype_uint /*line :647:39*/) []byte {
	size := int(n)
	return (*[1 << 30]byte)(unsafe.Pointer(buf))[:size:size]
}

// this function can't be put in callback.go
//export wrapReadRandGo
func wrapReadRandGo(buf * /*line :654:26*/_Ctype_char /*line :654:32*/, n  /*line :654:36*/_Ctype_uint /*line :654:42*/)  /*line :654:44*/_Ctype_uint /*line :654:50*/ {
	slice := createSlice(buf, n)
	ret, err := sRandReader.Read(slice)
	if ret == int(n) && err == nil {
		return n
	}
	return 0
}

// SetRandFunc --
func SetRandFunc(randReader io.Reader) {
	sRandReader = randReader
	if randReader != nil {
		( /*line :667:3*/_Cfunc_blsSetRandFunc /*line :667:18*/)(nil,  /*line :667:25*/_Ctype_ReadRandFunc /*line :667:39*/(unsafe.Pointer(( /*line :667:55*/_Cgo_ptr(_Cfpvar_fp_wrapReadRandCgo) /*line :667:71*/))))
	} else {
		// use default random generator
		( /*line :670:3*/_Cfunc_blsSetRandFunc /*line :670:18*/)(nil,  /*line :670:25*/_Ctype_ReadRandFunc /*line :670:39*/(unsafe.Pointer(nil)))
	}
}
